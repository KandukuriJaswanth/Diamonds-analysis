# -*- coding: utf-8 -*-
"""Diamonds.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qC0xXIUSvBFNCRpF9dtAKZkB4AYbKUjQ
"""

pip install ydata-profiling

import seaborn as sns
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from ydata_profiling import ProfileReport

from google.colab import drive
drive.mount('/content/drive')

"""# **Summary**
* Using Pandas, Matplotlib, and Seaborn, you can explore a Diamond dataset to analyze relationships between features like Carat, Cut, and Color, and how they influence the Diamond's price, uncovering key insights through statistical and visual analysis.

# **Data Overview**
"""

# Import the healthcare dataset from the specified CSV file using Pandas
df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/diamonds.csv')
df

"""# **Basic Metrics**"""

print(df.shape)

print(df.columns)

df = df.loc[:, ~df.columns.str.contains('^Unnamed')]

# Optionally, save the cleaned dataset
df.to_csv('cleaned_dataset.csv', index=False)

df.describe()

df.info()

"""# **Data Cleaning**"""

df.isnull().sum()

df.groupby('cut')['price'].mean()

"""# **Datatype Conversions**
* columns with string values (e.g., 'Ideal') to numeric, use `.astype()` or `.apply(pd.to_numeric, errors='coerce')` to handle conversion, coercing invalid values to NaN.
"""

df = df.apply(pd.to_numeric, errors='coerce')  # Convert non-numeric data to NaN

print(df.corr())

"""# **Unique Values**"""

# Check the number of unique values in each column of the DataFrame 'df'
# This helps in understanding the diversity of data in each column.
df.nunique()

"""# **Descriptive Statistics**"""

# Summary statistics for numerical columns
df.describe(include = 'all').T

# Assuming 'df' is your DataFrame containing the 'price' and 'carat' columns
df['price_per_carat'] = df['price'] / df['carat']
df['price_per_carat']

"""## **Data Visualization**"""

# Visualize the distribution of the 'price' column
sns.histplot(df['price'], kde=True, bins=30)
plt.title('Distribution of Diamond Prices')
plt.xlabel('Price')
plt.ylabel('Frequency')
plt.show()

plt.figure(figsize=(14, 8))

# KDE Plot of Carat
plt.subplot(2, 2, 1)
sns.kdeplot(df['carat'], fill=True, color='darkcyan')
plt.title('KDE Plot of Carat', fontsize=12)
plt.xlabel('Carat')
plt.ylabel('Density')

# Bar Plot for Cut Distribution
plt.subplot(2, 2, 2)
cut_counts = df['cut'].value_counts()
sns.barplot(x=cut_counts.index, y=cut_counts.values, palette='coolwarm')
plt.title('Bar Plot of Cut Distribution', fontsize=12)
plt.xlabel('Cut')
plt.ylabel('Count')

# Pie Chart for Color Distribution
plt.subplot(2, 2, 3)
color_counts = df['color'].value_counts()
plt.pie(color_counts.values, labels=color_counts.index, autopct='%1.1f%%', colors=sns.color_palette('pastel'))
plt.title('Pie Chart of Color Distribution', fontsize=12)

# Violin Plot for Clarity vs Price
plt.subplot(2, 2, 4)
sns.violinplot(x='clarity', y='price', data=df, color='cyan')  # Example with cyan color
plt.title('Violin Plot of Clarity vs Price', fontsize=12)
plt.xlabel('Clarity')
plt.ylabel('Price')

plt.tight_layout()
plt.show()

plt.figure(figsize=(5, 4))
sns.scatterplot(
    x='carat',
    y='price',
    hue='cut',
    size='carat',
    data=df,
    palette='viridis',
    alpha=0.7
)
plt.title('Scatter Plot of Carat vs Price by Cut', fontsize=14)
plt.xlabel('Carat')
plt.ylabel('Price')
plt.legend(title='Cut', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

plt.figure(figsize=(8,6))
sns.boxplot(x='clarity', y='price', hue='cut', data=df, palette='YlGnBu')
plt.title('Price Variation for Diamonds with Same Cut by clarity', fontsize=15)
plt.xlabel('Color', fontsize=12)
plt.ylabel('Price ($)', fontsize=12)
plt.legend(title='Cut', bbox_to_anchor=(1, 1))
plt.grid(True)
plt.show()

plt.figure(figsize=(5,20))

# Violin Plot of Price per Carat by Cut
sns.violinplot(x='cut', y='price_per_carat', data=df, palette='YlGnBu')
plt.title('Price per Carat by Cut', fontsize=12)

# Pair Plot of Multiple Variables
sns.pairplot(df[['price_per_carat', 'carat', 'cut', 'color', 'clarity']], hue='cut', palette='YlGnBu')
plt.suptitle('Pair Plot of Price per Carat, Carat, Cut, Color, and Clarity', fontsize=16, y=1.02)

# Regression Plot of Price per Carat vs Carat Size
sns.regplot(x='carat', y='price_per_carat', data=df, scatter_kws={'s': 10}, line_kws={'color': 'blue'})
plt.title('Price per Carat vs Carat Size with Regression Line', fontsize=12)

plt.tight_layout()
plt.show()

sns.pairplot(df, kind='scatter', palette='YlGnBu')
plt.suptitle('multiple features vs Price', y=1.02, fontsize=15)
plt.show()

"""# **Insights**
 The scatter plots between the dimensional variables (Length, Width, Depth) reveal a linear relationship, indicating that as the length or width of the diamond increases, the depth tends to rise as well, suggesting proportional consistency. However, some diamonds with larger lengths do not always have corresponding large depths, indicating flatter or more elongated shapes. The categorical variables (cut, color, clarity) show distinct distributions on the diagonal. Diamonds with higher clarity grades (IF, VVS1) may exhibit slightly larger dimensions. Additionally, diamonds with better cuts or color grades tend to cluster within specific dimension ranges, reflecting trends in higher-quality diamonds.
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Violin Plot for Carat Weight Distribution by Clarity
plt.figure(figsize=(10,6))
sns.violinplot(x='clarity', y='carat', data=df, palette='YlGnBu', inner='box')
plt.title('Carat Weight Distribution by Clarity', fontsize=15)
plt.xlabel('Clarity', fontsize=12)
plt.ylabel('Carat Weight', fontsize=12)
plt.grid(True)
plt.show()

# Pivot table for heatmap (Price per Carat by Clarity and Color)
price_per_carat_pivot = df.pivot_table(values='price_per_carat', index='clarity', columns='color', aggfunc='mean')

# Heatmap of Price per Carat by Clarity and Color
plt.figure(figsize=(10,6))
sns.heatmap(price_per_carat_pivot, annot=True, fmt=".0f", cmap='coolwarm', linewidths=0.5)
plt.title('Price per Carat by Clarity and Color', fontsize=15)
plt.xlabel('Color', fontsize=12)
plt.ylabel('Clarity', fontsize=12)
plt.show()

# Hexbin Plot of Depth vs Table
plt.figure(figsize=(10,6))
sns.jointplot(x='depth', y='table', data=df, kind='hex', color='darkslateblue', gridsize=30)
plt.suptitle('Hexbin Plot of Depth vs Table', y=1.02, fontsize=15)
plt.show()

"""# **Key Points:**
The code generates three visualizations: a violin plot showing carat weight distribution by clarity, a heatmap displaying the average price per carat based on clarity and color, and a hexbin plot illustrating the relationship between depth and table. These plots provide insights into diamond characteristics and trends.

### **Conclusion**

The visualizations reveal key insights into diamond characteristics. The violin plot highlights the distribution of carat weight by clarity, while the heatmap shows how price per carat varies with clarity and color. The hexbin plot emphasizes the relationship between depth and table, showcasing density patterns for better understanding.
"""

